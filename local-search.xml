<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>QuPing - 评分功能性能测试与优化</title>
    <link href="/2024/12/08/QuPing-%E8%AF%84%E5%88%86%E5%8A%9F%E8%83%BD%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E4%B8%8E%E4%BC%98%E5%8C%96/"/>
    <url>/2024/12/08/QuPing-%E8%AF%84%E5%88%86%E5%8A%9F%E8%83%BD%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E4%B8%8E%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="QuPing-评分功能性能测试与优化"><a href="#QuPing-评分功能性能测试与优化" class="headerlink" title="QuPing - 评分功能性能测试与优化"></a>QuPing - 评分功能性能测试与优化</h1><p>通过Jmeter模拟1000个用户同时对一个评分项进行打分，来对比相同业务不同逻辑的性能优劣。</p><p>数据生成代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SneakyThrows</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">doRatingData</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">userCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span>;<br>    <span class="hljs-type">Long</span> <span class="hljs-variable">ratingId</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">totalRating</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//创建一个测试评分</span><br>    log.info(<span class="hljs-string">&quot;创建测试用评分...&quot;</span>);<br>    <span class="hljs-type">Rating</span> <span class="hljs-variable">rating</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Rating</span>();<br>    rating.setTitle(<span class="hljs-string">&quot;测试用评分&quot;</span>);<br>    ratingMapper.insert(rating);<br>    log.info(<span class="hljs-string">&quot;创建完毕,评分id为:&#123;&#125;&quot;</span>,rating.getId());<br>    ratingId = rating.getId();<br>    log.info(<span class="hljs-string">&quot;开始生成&#123;&#125;个用户token与随机请求体&quot;</span>,userCount);<br>    <span class="hljs-type">Method</span> <span class="hljs-variable">getUserToken</span> <span class="hljs-operator">=</span> userService.getClass().getDeclaredMethod(<span class="hljs-string">&quot;getUserToken&quot;</span>, User.class);<br>    getUserToken.setAccessible(<span class="hljs-literal">true</span>);<br>    <span class="hljs-keyword">try</span>(<span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;src/main/resources/doRatingData.csv&quot;</span>);<br>        <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">tokenFos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;src/main/resources/token.csv&quot;</span>))&#123;<br>        fos.write(<span class="hljs-string">&quot;token,requestBody\n&quot;</span>.getBytes());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=userCount;i++)&#123;<br>            <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>            user.setNickName(String.format(<span class="hljs-string">&quot;test-%s&quot;</span>, RandomUtil.randomString(<span class="hljs-number">5</span>)));<br>            user.setPassword(<span class="hljs-string">&quot;111111&quot;</span>);<br>            user.setFirstLogin(<span class="hljs-literal">false</span>);<br>            userMapper.insert(user);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> (String) getUserToken.invoke(userService, user);<br>            tokenFos.write((token+<span class="hljs-string">&quot;\n&quot;</span>).getBytes());<br>            <span class="hljs-type">int</span> <span class="hljs-variable">score</span> <span class="hljs-operator">=</span> RandomUtil.randomInt(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>);<span class="hljs-comment">//[1,6)</span><br>            HashMap&lt;String, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>            map.put(<span class="hljs-string">&quot;ratingId&quot;</span>, ratingId.toString());<br>            map.put(<span class="hljs-string">&quot;score&quot;</span>, String.valueOf(score));<br>            <span class="hljs-type">String</span> <span class="hljs-variable">requestBody</span> <span class="hljs-operator">=</span> JSONUtil.toJsonStr(map);<br>            fos.write(String.format(<span class="hljs-string">&quot;%s %s\n&quot;</span>,token,requestBody).getBytes());<br>            totalRating+=score;<br>        &#125;<br>    &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>        log.error(e.getMessage());<br>    &#125;<br>    log.info(<span class="hljs-string">&quot;生成完毕,总评分&#123;&#125;,评分人数&#123;&#125;,期望结果(保留2位小数)&#123;&#125;&quot;</span>,<br>            totalRating<br>            ,userCount<br>            ,Math.round((<span class="hljs-type">double</span>) totalRating / userCount * <span class="hljs-number">100</span>) / <span class="hljs-number">100.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>将数据保存为csv文件，然后通过jmeter获取并发送请求</p><p>通过${token}获取每一行的token，${requestBody}获取请求体</p><p>方式一无优化逻辑，朴素法：</p><p>为了防止在并发的情况下出现类似脏度或者覆盖等情况，我们可以考虑对整个过程进行加锁</p><p>保证每次只有一个线程在操作这些数据。</p><p>请求流程：</p><blockquote><p>前端发送请求：&#x2F;rating&#x2F;doRating 请求方式为POST,请求参数为json包括ratingId和score，分别表示评分项的id和用户的打分，请求头需要带上Token </p><p>后端解析token获取userId并且通过ratingId获取对应的Rating和UserRatingMapping,如果用户第一次评分则插入一行mapping记录否则修改并update</p></blockquote><p>机器配置：</p><p><img src="https://cdn.yunjiujiu.xyz/blogimages/image-20241210215252192.png" alt="image-20241210215252192"></p><p>开始测试：<br>数据库中只有1000条user数据和1条rating数据</p><p>jmeter配置1000个线程，1s的ramp-up qps为1000</p><p>模拟1000个用户在1s内同时对一个评分进行打分。</p><p>前1000次需要insert1000条后续都只要update</p><p>5000次结果如下：</p><p><img src="https://cdn.yunjiujiu.xyz/blogimages/image-20241210220134559.png" alt="image-20241210220134559"></p><p>查看数据库，结果符合预期，表示没有出现并发问题。</p><p>平均第一次1000次insert的情况下平均为4s，后续加上4000次update总共平均是2.5s，最大值达到8s，虽然说没有异常，但是还是很慢的，而且最小值最大值相差太大了，不稳定。</p><h2 id="设计优化"><a href="#设计优化" class="headerlink" title="设计优化"></a>设计优化</h2><p>对应每个评分项的最终得分的结果：最终得分 &#x3D; 总的得分 &#x2F; 评分人数</p><p>如果一个用户进行了打分，那么他的打分会被记录在UserRatingMapping中</p><p>也就是说，Rating中的最终评分(score)、评分人数(count)，只是作为展示和方便计算的作用</p><p>实际上的结果其实还是保存在UserRatingMapping中，即使Rating中的最终评分数据丢失了</p><p>我们还是能够通过查看UserRatingMapping中哪些用户对哪些评分项的打分来计算出对应的最终分数</p><p>所以就得出了一个结论，用户对评分项打分或者修改打分，本质上都是在修改UserRatingMapping，和Rating的关系不大</p><p>所以这个问题就变成了对于UserRatingMapping的高并发设计</p><p>首先是插入的情况，我们需要去避免重复的插入，可以在user_rating_mapping表中给user_id和rating_id添加唯一索引，因为一般都是rating的数量大于user所以user_id在前面会好点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE user_rating_mapping<br>ADD UNIQUE INDEX unique_user_rating (user_id, rating_id);<br></code></pre></td></tr></table></figure><p>然后是修改的情况，为了防止我们的修改被覆盖，我们可以使用乐观锁，因为评分只在意结果无所谓过程，所以直接用score作为乐观锁，如果失败了直接返回即可。</p><p>然后Rating这个点，我们把他放在Redis中进行修改，利用Redis单线程的特性，来规避并发问题(可以用lua脚本)，前端获取结果通过缓存获取，也能快速的得到结果。</p><p>对于数据的持久化，首先因为我们只关系最新的打分结果，不关心之前的过程，而且每次都是直接在redis上修改数据，所以redis上永远都是最新的数据，我们只需要定期将redis中的数据保存到数据库即可。</p><p>在简单的情况下我们可以通过spring的事件，在每次redis更新后都发送一个事件，通知去持久化redis中的数据，为了防止redis宕机导致数据丢失，可以将每次更新的rating实体作为参数传给监听器，叫监听器去将该数据持久化到数据库。</p><p>当然也可以用消息中间件代替，这个适合分布式的情况，并且消息中间件有更完善的消息处理机制。</p><p>最终我将打分逻辑改成：</p><p>通过乐观锁更新UserRatingMapping<br>如果更新成功，修改redis中的评分信息<br>更新失败，返回”你点的太快了”<br>在redis中检查评分的标志位，如果为1则直接返回<br>如果为0或者没有则设置为1,发布一个延迟一秒后发布的事件<br>监听器收到事件后，将标志位设置为0，并且从redis中获取评分数据保存到数据库中</p><p>标志位和延迟的组合可以防止每次请求都去更新数据库，当一个请求进来，发现标志位为1则表示接下该请求对redis的更改会在未来的时间内&lt;&#x3D;1s被更新到数据库，所以该请求就不必要去访问数据库了。这样进行了一个限流的操作，就是假设2s内有5000个请求来，可能就只会访问两次数据库，大大节省了资源。</p><p>开始测试：</p><p>同样的机器和测试参数：</p><p>第一次1000平均1513ms，最小1190ms，最大1861对比4s平均大概提升了60%多</p><p><img src="https://cdn.yunjiujiu.xyz/blogimages/image-20241210222940029.png" alt="image-20241210222940029"></p><p>最终5000次的结果发现平均才464ms，整体提升了80%!!!</p><p>并且也是0异常数据库结果符合预期。</p><h2 id="途中遇到的BUG"><a href="#途中遇到的BUG" class="headerlink" title="途中遇到的BUG"></a>途中遇到的BUG</h2><p>一开始我打算先试试就正常从数据库中拿数据然后修改并更新，为了防止出错，我加上了事务注解@Transactional，还有为了防止并发的synchronized来修饰整个doRating方法</p><p>结果测了几次还是会有并发问题，就是评分项的评分count总是小于实际的请求数。</p><p>但是我明明加了synchronized啊？这就很奇怪了，后面陆续从请求是否全部到达、数据库执行是否有出错的，synchronized锁对象等这方面排查，但是都是正常的。后面无意把@Transactional注解去掉后，才得以解决。</p><p>后面想明白了就是@Transactional注解的问题，因为我的同步方法没有把事务囊括在其中，所以后续在高并发的情况会出现事务的并发问题。因为用了@Transactional注解，Spring是使用代理来执行我的同步方法，具体流程就是先开启事务，然后执行我的同步方法，提交事务。这就导致并发的情况下多个事务相互干扰，导致了不可重复读的问题，并且相互提交并覆盖数据。</p><p>所以说如果要使用同步方法操作事务，记得把事务也囊括在里面</p><p>可以使用编程式事务，或者在调用事务方法前加锁，但是不要在同类中调用，否则这样事务注解会失效。</p>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>BUG</tag>
      
      <tag>QuPing</tag>
      
      <tag>测试</tag>
      
      <tag>Jmeter</tag>
      
      <tag>高并发</tag>
      
      <tag>性能优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis-Plus字段自动填充(踩坑)</title>
    <link href="/2024/12/08/Mybatis-Plus%E5%AD%97%E6%AE%B5%E8%87%AA%E5%8A%A8%E5%A1%AB%E5%85%85-%E8%B8%A9%E5%9D%91/"/>
    <url>/2024/12/08/Mybatis-Plus%E5%AD%97%E6%AE%B5%E8%87%AA%E5%8A%A8%E5%A1%AB%E5%85%85-%E8%B8%A9%E5%9D%91/</url>
    
    <content type="html"><![CDATA[<h1 id="Mybatis-Plus字段自动填充-踩坑"><a href="#Mybatis-Plus字段自动填充-踩坑" class="headerlink" title="Mybatis-Plus字段自动填充(踩坑)"></a>Mybatis-Plus字段自动填充(踩坑)</h1><blockquote><p>在将项目从Mybatis换到Plus的时候，想给公共字段配置自动填充，但是中途出了点问题踩了一些坑</p></blockquote><p>背景：给数据库表添加create_time、update_time两个公共字段，通过Mybatis-Plus实现自动填充</p><p>首先给数据库表中添加这两个字段</p><p><code>create_time</code>类型为timestamp默认为null</p><p><code>update_time</code>类型为timestamp默认为null</p><p>然后给对应实体类中添加对应属性字段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@TableField(fill = FieldFill.INSERT)</span><br><span class="hljs-keyword">private</span> LocalDateTime createTime;<br><span class="hljs-meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span><br><span class="hljs-keyword">private</span> LocalDateTime updateTime;<br></code></pre></td></tr></table></figure><p>使用@TableField注解，指定自动填充的类型，比如FieldFill.INSERT表示在插入的时候自动填充</p><p>FieldFill.INSERT_UPDATE在插入和删除的时候填充等</p><p>创建一个Handler实现MetaObjectHandler接口重写insertFill、updateFill方法在里面实现自己的填充逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 默认的自动填充策略：</span><br><span class="hljs-comment"> * 如果已经存在了值，则不填充</span><br><span class="hljs-comment"> * 如果填充的值为null也不填充</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FieldAutoFillHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MetaObjectHandler</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertFill</span><span class="hljs-params">(MetaObject metaObject)</span> &#123;<br>        log.info(<span class="hljs-string">&quot;执行插入填充...&quot;</span>);<br>        <span class="hljs-built_in">this</span>.strictInsertFill(metaObject, <span class="hljs-string">&quot;createTime&quot;</span>, LocalDateTime.class, LocalDateTime.now());<br>        <span class="hljs-built_in">this</span>.strictUpdateFill(metaObject, <span class="hljs-string">&quot;updateTime&quot;</span>, LocalDateTime.class, LocalDateTime.now());<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateFill</span><span class="hljs-params">(MetaObject metaObject)</span> &#123;<br>        log.info(<span class="hljs-string">&quot;执行更新填充...&quot;</span>);<br>        <span class="hljs-built_in">this</span>.setFieldValByName(<span class="hljs-string">&quot;updateTime&quot;</span>, LocalDateTime.now(), metaObject);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>之后在更新或者删除的时候就可以实现自动填充</p><h2 id="自动填充出现失效"><a href="#自动填充出现失效" class="headerlink" title="自动填充出现失效"></a>自动填充出现失效</h2><p>正常一般这样配置后就可以用了，但是有些原因可能会导致失效，以及一些注意事项。</p><p>实体类属性的字段上是否加上了@TableField注解</p><p>数据库数据类型，和实体类数据类型是否对应</p><p>Handler是否加了@Component注解交给Spring管理</p><p>strictInsert&#x2F;UpdateFill和setFieldValByName的区别：</p><p>这两个方法都是用来实现设置需要自动填充的字段的值</p><p>但是有些许差异首先strictInsert&#x2F;UpdateFill的默认填充策略是：<code>如果实体类中需要自动填充的字段已经有值了(可能是在业务逻辑中就已经设置，或者是数据库中查出来的),那么当前值就不会进行填充，或者你想给一个字段填充null值也是不可以的。</code></p><p>而setFieldValByName不一样，他就是直接覆盖</p><p>所以说有时候发现update_time不更新，有可能是在update的时候传入的实体类中已经有之前update_time，所以使用strictUpdateFill填充当前时间就会不生效，可以直接使用setFieldValByName</p><p>还有一种特殊情况，也是我自己遇到的，就是如果你的mapper接口继承了BaseMapper，里面会默认提供一些接口比如insert等，但是如果你还写了对应的insert的xml文件，那么在自动填充的时候可能会走你的xml文件中的sql逻辑，而不是框架自带的，这样的话自动填充可能会失效如果你的sql中没有去主动设置create_time、update_time这些值。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mypatis-Plus</tag>
      
      <tag>BUG</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker学习记录</title>
    <link href="/2024/12/04/docker%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <url>/2024/12/04/docker%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker学习记录"><a href="#Docker学习记录" class="headerlink" title="Docker学习记录"></a>Docker学习记录</h1><blockquote><p>Author: Punny</p><p>Date: 2024&#x2F;11&#x2F;16</p></blockquote><blockquote><p>参考文档：<a href="https://yeasy.gitbook.io/docker_practice">https://yeasy.gitbook.io/docker_practice</a></p></blockquote><ul><li>使用yum安装Docker</li></ul><p>我的虚拟机中装的是CentOS注意一些要求：</p><blockquote><p>Docker 支持 64 位版本 CentOS 7&#x2F;8，并且要求内核版本不低于 3.10。 CentOS 7 满足最低内核的要求，但由于内核版本比较低，部分功能（如 <code>overlay2</code> 存储层驱动）无法使用，并且部分功能可能不太稳定。</p></blockquote><ul><li>卸载旧版</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> yum remove docker \<br>                  docker-client \<br>                  docker-client-latest \<br>                  docker-common \<br>                  docker-latest \<br>                  docker-latest-logrotate \<br>                  docker-logrotate \<br>                  docker-selinux \<br>                  docker-engine-selinux \<br>                  docker-engine<br></code></pre></td></tr></table></figure><ul><li>安装依赖包</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> yum install -y yum-utils<br></code></pre></td></tr></table></figure><p>报错了，可能是镜像源的问题,没报错的可以直接忽略这一步</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs bash">已加载插件：fastestmirror, langpacks<br>Loading mirror speeds from cached hostfile<br>Could not retrieve mirrorlist http://mirrorlist.centos.org/?release=7&amp;<span class="hljs-built_in">arch</span>=x86_64&amp;repo=os&amp;infra=stock error was<br>14: curl#6 - <span class="hljs-string">&quot;Could not resolve host: mirrorlist.centos.org; 未知的错误&quot;</span><br><br><br> One of the configured repositories failed (未知),<br> and yum doesn<span class="hljs-string">&#x27;t have enough cached data to continue. At this point the only</span><br><span class="hljs-string"> safe thing yum can do is fail. There are a few ways to work &quot;fix&quot; this:</span><br><span class="hljs-string"></span><br><span class="hljs-string">     1. Contact the upstream for the repository and get them to fix the problem.</span><br><span class="hljs-string"></span><br><span class="hljs-string">     2. Reconfigure the baseurl/etc. for the repository, to point to a working</span><br><span class="hljs-string">        upstream. This is most often useful if you are using a newer</span><br><span class="hljs-string">        distribution release than is supported by the repository (and the</span><br><span class="hljs-string">        packages for the previous distribution release still work).</span><br><span class="hljs-string"></span><br><span class="hljs-string">     3. Run the command with the repository temporarily disabled</span><br><span class="hljs-string">            yum --disablerepo=&lt;repoid&gt; ...</span><br><span class="hljs-string"></span><br><span class="hljs-string">     4. Disable the repository permanently, so yum won&#x27;</span>t use it by default. Yum<br>        will <span class="hljs-keyword">then</span> just ignore the repository <span class="hljs-keyword">until</span> you permanently <span class="hljs-built_in">enable</span> it<br>        again or use --enablerepo <span class="hljs-keyword">for</span> temporary usage:<br><br>            yum-config-manager --<span class="hljs-built_in">disable</span> &lt;repoid&gt;<br>        or<br>            subscription-manager repos --<span class="hljs-built_in">disable</span>=&lt;repoid&gt;<br><br>     5. Configure the failing repository to be skipped, <span class="hljs-keyword">if</span> it is unavailable.<br>        Note that yum will try to contact the repo. when it runs most commands,<br>        so will have to try and fail each time (and thus. yum will be be much<br>        slower). If it is a very temporary problem though, this is often a <span class="hljs-built_in">nice</span><br>        compromise:<br><br>            yum-config-manager --save --<span class="hljs-built_in">setopt</span>=&lt;repoid&gt;.skip_if_unavailable=<span class="hljs-literal">true</span><br><br>Cannot find a valid baseurl <span class="hljs-keyword">for</span> repo: base/7/x86_64<br><br></code></pre></td></tr></table></figure><p>配置阿里云yum源</p><p>去到yum的仓库源目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /etc/yum.repos.d<br></code></pre></td></tr></table></figure><p>利用wget下载阿里云镜像源配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget http://mirrors.aliyun.com/repo/Centos-7.repo<br></code></pre></td></tr></table></figure><p>备份原来的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mv</span> CentOS-Base.repo CentOS-Base.repo.bak<br></code></pre></td></tr></table></figure><p>用刚才下载的替换</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mv</span> Centos-7.repo CentOS-Base.repo<br></code></pre></td></tr></table></figure><p>清除缓存更新</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum clean all<br>yum makecache<br>yum update<br></code></pre></td></tr></table></figure><p>完成后再次安装依赖包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> yum install -y yum-utils<br></code></pre></td></tr></table></figure><ul><li>切换docker的yum镜像源为阿里云仓库</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> yum-config-manager \<br>    --add-repo \<br>    https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo<br><br><span class="hljs-built_in">sudo</span> sed -i <span class="hljs-string">&#x27;s/download.docker.com/mirrors.aliyun.com\/docker-ce/g&#x27;</span> /etc/yum.repos.d/docker-ce.repo<br></code></pre></td></tr></table></figure><ul><li>正式安装docker</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> yum install docker-ce docker-ce-cli containerd.io<br></code></pre></td></tr></table></figure><ul><li>执行docker version验证是否安装完成</li></ul><blockquote><p>Client: Docker Engine - Community<br>Version:           26.1.4<br>API version:       1.45<br>Go version:        go1.21.11<br>Git commit:        5650f9b<br>Built:             Wed Jun  5 11:32:04 2024<br>OS&#x2F;Arch:           linux&#x2F;amd64<br>Context:           default<br>Cannot connect to the Docker daemon at unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;docker.sock. Is the docker daemon running?</p></blockquote><p>显示docker版本信息，表示安装成功！</p><ul><li>启动docker</li></ul><blockquote><p>Cannot connect to the Docker daemon at unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;docker.sock. Is the docker daemon running?表示docker未启动</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> systemctl <span class="hljs-built_in">enable</span> docker<br><span class="hljs-built_in">sudo</span> systemctl start docker<br></code></pre></td></tr></table></figure><p>再次运行docker version即可看见更详细的内容</p><blockquote><p>Client: Docker Engine - Community<br>Version:           26.1.4<br>API version:       1.45<br>Go version:        go1.21.11<br>Git commit:        5650f9b<br>Built:             Wed Jun  5 11:32:04 2024<br>OS&#x2F;Arch:           linux&#x2F;amd64<br>Context:           default</p><p>Server: Docker Engine - Community<br>Engine:<br>Version:          26.1.4<br>API version:      1.45 (minimum version 1.24)<br>Go version:       go1.21.11<br>Git commit:       de5c9cf<br>Built:            Wed Jun  5 11:31:02 2024<br>OS&#x2F;Arch:          linux&#x2F;amd64<br>Experimental:     false<br>containerd:<br>Version:          1.6.33<br>GitCommit:        d2d58213f83a351ca8f528a95fbd145f5654e957<br>runc:<br>Version:          1.1.12<br>GitCommit:        v1.1.12-0-g51d5e94<br>docker-init:<br>Version:          0.19.0<br>GitCommit:        de40ad0</p></blockquote><ul><li>测试运行是否正常，使用hello world镜像</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run --<span class="hljs-built_in">rm</span> hello-world<br></code></pre></td></tr></table></figure><p>报错了（没报错可以跳过）</p><blockquote><p>Unable to find image ‘hello-world:latest’ locally<br>docker: Error response from daemon: Get “<a href="https://registry-1.docker.io/v2/">https://registry-1.docker.io/v2/</a>“: net&#x2F;http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers).<br>See ‘docker run –help’.</p></blockquote><p>原因是docker的镜像源默认是国外，最近应该是被墙了，国内很多也下架了</p><p>需要切换成国内有效的镜像源参考网站：<a href="https://status.1panel.top/status/docker">https://status.1panel.top/status/docker</a></p><p>配置后可以执行docker pull 但是docker search还是不行，可以去下面的网站找docker镜像：<a href="https://docker.fxxk.dedyn.io/">https://docker.fxxk.dedyn.io/</a></p><p>新增配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> vi /etc/docker/daemon.json<br></code></pre></td></tr></table></figure><p>编辑内容</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;registry-mirrors&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-string">&quot;https://docker.m.daocloud.io&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;https://docker.1panel.live&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;https://hub.rat.dev&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;https://hub.xdark.top&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;https://hub.littlediary.cn&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;https://dockerpull.org&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;https://hub.crdz.gq&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;https://docker.unsee.tech&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;https://registry.dockermirror.com&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;https://docker.m.daocloud.io&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;https://docker.ketches.cn&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;https://docker.1ms.run&quot;</span><br>    <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>esc退出编辑模式:wq!保存</p><p>重启docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> service docker restart<br></code></pre></td></tr></table></figure><p>再次执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run --<span class="hljs-built_in">rm</span> hello-world<br></code></pre></td></tr></table></figure><p>成功运行</p><blockquote><p>Hello from Docker!<br>This message shows that your installation appears to be working correctly.</p><p>To generate this message, Docker took the following steps:</p><ol><li>The Docker client contacted the Docker daemon.</li><li>The Docker daemon pulled the “hello-world” image from the Docker Hub.<br>(amd64)</li><li>The Docker daemon created a new container from that image which runs the<br>executable that produces the output you are currently reading.</li><li>The Docker daemon streamed that output to the Docker client, which sent it<br>to your terminal.</li></ol><p>To try something more ambitious, you can run an Ubuntu container with:<br> $ docker run -it ubuntu bash</p><p>Share images, automate workflows, and more with a free Docker ID:<br> <a href="https://hub.docker.com/">https://hub.docker.com/</a></p><p>For more examples and ideas, visit:<br> <a href="https://docs.docker.com/get-started/">https://docs.docker.com/get-started/</a></p></blockquote><ul><li>docker的命令</li></ul><p>docker search 搜索镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker search mysql<br></code></pre></td></tr></table></figure><p>docker pull 拉取镜像</p><p>也可以通过指定镜像的tag来拉取指定版本的镜像</p><p>没有指定tag默认为:latest</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull mysql <span class="hljs-comment">#默认拉取最新版mysql:latest</span><br>docker pull mysql:5.7 <span class="hljs-comment">#通过tag指定版本</span><br></code></pre></td></tr></table></figure><p>docker images 查看镜像列表</p><blockquote><p>REPOSITORY    TAG       IMAGE ID              CREATED                SIZE<br>mysql                latest    10db11fef9ce       4 weeks ago          602MB<br>mysql                5.7         5107333e08a8    11 months ago     501MB<br>hello-world       latest    d2c94e258dcb    18 months ago    13.3kB</p></blockquote><p>可以查看镜像源、版本、镜像id、创建时间、和大小等信息</p><p>docker rmi 删除镜像</p><p>可以通过镜像名称、或者镜像id来删除镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker rmi mysql <span class="hljs-comment">#只删除mysql:latest</span><br>docker rmi mysql:5.7<br>docker rmi d2c94e258dcb <span class="hljs-comment">#根据镜像id删除</span><br></code></pre></td></tr></table></figure><p>docker run</p><blockquote><p>docker run命令用于指定一个镜像模板，并以此创建并启动一个容器</p><p>有很多参数来设置容器的一些配置</p></blockquote><p>docker run [可选参数] 镜像名&#x2F;镜像id</p><table><thead><tr><th>参数</th><th>作用</th><th>示例</th></tr></thead><tbody><tr><td>–name</td><td>为容器指定一个名称，便于管理。</td><td>docker run –name my-container ubuntu</td></tr><tr><td>-d</td><td>以 <strong>后台模式</strong> 运行容器。类似nohop</td><td>docker run -d nginx</td></tr><tr><td>-it</td><td>允许用户以交互模式运行容器，并附加到容器的终端（常用于调试）。<br />运行容器后会直接进入容器内部，可以通过exit命令退出容器并停止容器，Ctrl + P + Q可以退出容器但是不停容器</td><td>docker run -it ubuntu &#x2F;bin&#x2F;bash</td></tr><tr><td>–rm</td><td>在容器停止后自动删除容器。</td><td>docker run –rm ubuntu</td></tr><tr><td>-p</td><td>映射主机和容器的端口，用于访问容器内的服务。-p 主机端口:容器端口。也可以直接指定容器端口-p 容器端口</td><td>docker run -p 8080:80 nginx</td></tr><tr><td>-P</td><td>自动随机映射主机的可用端口到容器的暴露端口。</td><td>docker run -P nginx</td></tr></tbody></table><p>docker ps 列出正在运行的容器信息</p><p>docker ps -a 列出当前所有的容器的信息</p><p>docker rm 删除容器</p><p>docker start&#x2F;restart 启动&#x2F;重启一个已经存在的容器</p><p>docker stop 停止容器</p><p>docker kill 强制停止容器</p><p>docker stats 查看容器运行情况</p><ul><li>为什么使用docker run -d centos启动容器后，容器后马上停止</li></ul><blockquote><p>涉及到容器的生命周期和其关联的主进程相关的内容，后续再在这里探讨—2024&#x2F;11&#x2F;17</p></blockquote><ul><li>docker logs 查看容器的日志</li></ul><blockquote><p>涉及到的参数也有很多，后续再探讨—2024&#x2F;11&#x2F;17</p></blockquote><p>查看容器内的进程信息 docker top</p><p>查看容器的元数据信息 docker inspect</p><p>以交互的形式进入当前正在运行的容器(会开启一个新的交互终端)docker exec -it 容器id&#x2F;容器名称 需要执行的命令</p><p>比如进入mysql</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it mysql-container mysql -u root -p<br></code></pre></td></tr></table></figure><p>进入容器正在运行的终端docker attach 容器id&#x2F;容器名称</p><p>容器与本机文件直接的拷贝docker cp </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">cp</span> /path/on/host my_container:/path/in/container <span class="hljs-comment">#将本机文件/path/on/host拷贝到容器my_container的/path/in/container路径下</span><br>docker <span class="hljs-built_in">cp</span> my_container:/path/in/container /path/on/host <span class="hljs-comment">#反过来就是把容器内的文件拷贝到本机</span><br><span class="hljs-comment">#不需要容器正在运行也可以进行拷贝，容器的路径格式为container-name:/path</span><br></code></pre></td></tr></table></figure><ul><li>练习：利用docker部署tomcat</li></ul><p>首先拉取镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull tomcat<br></code></pre></td></tr></table></figure><p>运行容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -d --name test-tomcat -p 8080:8080 tomcat <span class="hljs-comment">#表示后台运行一个容器名称为‘test-tomcat’的tomcat镜像，并且将本机的8080端口映射到容器的8080端口</span><br></code></pre></td></tr></table></figure><p>外部浏览器访问：虚拟机ip:8080 192.168.154.128:8080结果发现是404</p><p>进入容器内部查看原因</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it test-tomcat /bin/bash<br></code></pre></td></tr></table></figure><p>利用ls命令查看文件内容可以看见熟习的tomcat文件结构</p><blockquote><p>bin           conf             lib      logs            NOTICE     RELEASE-NOTES  temp     webapps.dist<br>BUILDING.txt  CONTRIBUTING.md  LICENSE  native-jni-lib  README.md  RUNNING.txt    webapps  work</p></blockquote><p>发现webapps中是空的，原因是docker的tomcat镜像和原版相比有一些差异或者是精简</p><p>但是webapps.dist中是有的</p><blockquote><p>docs  examples  host-manager  manager  ROOT</p></blockquote><p>利用命令将webapps.dist目录下的文件及其子目录下的文件都复制过去用cp 参数-r来实现</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cp</span> -r ./wabapps.dist/* ./wabapps<br></code></pre></td></tr></table></figure><p>再次访问192.168.154.128:8080就成功了</p><ul><li>练习，利用docker部署elasticsearch，并限制内存</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -d --name elasticsearch \<br>  -p 9200:9200 -p 9300:9300 \<br>  -e <span class="hljs-string">&quot;discovery.type=single-node&quot;</span> \<br>  -e <span class="hljs-string">&quot;ES_JAVA_OPTS=-Xms128m -Xmx512m&quot;</span> \<br>  elasticsearch:7.6.2<br></code></pre></td></tr></table></figure><p>注意：elasticsearch貌似没有latest的tag所以pull的时候要指定版本</p><p>访问： curl localhost:9200</p><blockquote><p>{<br>“name” : “e66c5bc98b22”,<br>“cluster_name” : “docker-cluster”,<br>“cluster_uuid” : “8R4Q4fB_QjCMws3aJw6e6Q”,<br>“version” : {<br> “number” : “7.6.2”,<br> “build_flavor” : “default”,<br> “build_type” : “docker”,<br> “build_hash” : “ef48eb35cf30adf4db14086e8aabd07ef6fb113f”,<br> “build_date” : “2020-03-26T06:34:37.794943Z”,<br> “build_snapshot” : false,<br> “lucene_version” : “8.4.0”,<br> “minimum_wire_compatibility_version” : “6.8.0”,<br> “minimum_index_compatibility_version” : “6.0.0-beta1”<br>},<br>“tagline” : “You Know, for Search”<br>}</p></blockquote><p>部署成功</p><ul><li><p>安装图形化界面portainer</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -d -p 8088:9000 \<br>--restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=<span class="hljs-literal">true</span> portainer/portainer<br></code></pre></td></tr></table></figure><p>开放在8088端口</p></li><li><p>docker镜像对比操作系统镜像为什么这么小？</p><blockquote><p>操作系统镜像，比如linux镜像一般由内核(Kernel)还有Rootfs(root file system)所组成，而docker镜像与宿主机共享内核，镜像中只会包含rootfs，并且针对不同镜像也可以对rootfs进行适当的精简，所以docker镜像可以很小。</p><p>并且docker镜像采用分层结构，在pull的时候docker会分层下载镜像文件，如果发现有些层已经在本地下载过，那就可以直接复用，无需二次下载。</p></blockquote></li><li><p>数据挂载 -v</p><p>可以通过数据挂载，将容器中的文件挂载到容器外，这样即使容器被删了数据也不会消失</p><p>-v 本机路径:容器内路径</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -v /home/test:/home centos <span class="hljs-comment">#将centos容器中的/home目录中的文件挂载到本机/home/test目录下</span><br></code></pre></td></tr></table></figure></li><li><p>练习：部署mysql</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -d -p 3306:3306 \<br>-e MYSQL_ROOT_PASSWORD=123456 \<br>-v /home/mysql/conf:/etc/mysql/conf.d \<br>-v /home/mysql/data:/var/lib/mysql mysql <span class="hljs-comment">#分别将mysql配置和数据挂载到本地通过-e配置环境设置root密码</span><br></code></pre></td></tr></table></figure><p>具名挂载和匿名挂载</p><p>在挂载数据卷的时候可以为数据卷指定名字后续可以在docker volume ls中看到</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">-v /容器内路径 <span class="hljs-comment">#匿名挂载</span><br>-v 卷名:/容器内路径 <span class="hljs-comment">#具名挂载</span><br>-v /宿主机路径://容器内路径 <span class="hljs-comment">#具体路径挂载</span><br></code></pre></td></tr></table></figure><p>也可以通过docker volume inspect &lt;卷名&gt;来查看卷的具体信息</p><p>共享容器的数据卷</p><p>–volumes-from 容器名</p></li><li><p>docker部署Reids</p><p>先创建本地的数据目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> /data/redis<br></code></pre></td></tr></table></figure><p>部署命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run \<br>--restart=always \<br>-d \<br>--name redis-container \<br>-p 6379:6379 \<br>-v /data/redis:/data \<br>redis:latest \<br>redis-server --appendonly <span class="hljs-built_in">yes</span> \<br>--requirepass <span class="hljs-string">&quot;123456&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run \<br>--restart=always \ <span class="hljs-comment">#开机启动</span><br>-d \ <span class="hljs-comment">#后台运行</span><br>--name redis-container \ <span class="hljs-comment">#命名容器为redis-container</span><br>-p 6379:6379 \ <span class="hljs-comment">#端口映射</span><br>-v /data/redis:/data \ <span class="hljs-comment">#将数据挂载到本地</span><br>redis:latest \ <span class="hljs-comment">#指定版本</span><br>redis-server --appendonly <span class="hljs-built_in">yes</span> \ <span class="hljs-comment">#开启AOF持久化</span><br>--requirepass <span class="hljs-string">&quot;123456&quot;</span> <span class="hljs-comment">#设置密码</span><br></code></pre></td></tr></table></figure><p>进入容器内通过客户端连接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it redis-container redis-cli<br>auth 123456<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/12/04/hello-world/"/>
    <url>/2024/12/04/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
